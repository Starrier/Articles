# wait /notify

### 通知

线程更新了系统的状态，使得其他线程所需的保护条件得以满足的时候唤醒那些被暂停的线程的过程。

{% hint style="info" %}
1. 等待线程对保护条件的判断，Object.wait\(\) 的调用总是应该放在相应对象所引导的临界区中的一个循环语句中。
2. 等待线程对保护条件的判断，Object.wait\(\) 的执行以及目标动作的执行必须放在同一个对象（内部锁）所引导的临界区中。
3. Object.wait\(\) 暂停当前线程时释放的锁只是与该 wait 方法所属对象的内部锁。当前线程所持有的其他内部锁、显示锁并不会因此而释放。
{% endhint %}

{% hint style="info" %}
等待线程和通知线程必须调用同一个对象的 wait 方法，notify 方法来实现等待和通知，调用一个对象的 notify 方法所唤醒的线程仅是该对象上的一个任意等待线程。notify 方法调用应该尽可能放在靠近临界区结束的地方。
{% endhint %}

 另外，等待线程对保护条件的判断以及目标动作的执行必须是个原子操作，否则可能产生竞态目标动作被执行前的那一刻其他线程对共享变量的更新又使得保护条件重新不成立。因此，目标动作的执行必须和保护条件的判断以及Object.wait（）调用放在同一个对象所引导的临界区中 。

## wait/notify 的性能开销和问题

### 过早唤醒

### 信号丢失

使用 Object.notifyAll\(\).

### 欺骗性唤醒

也会导致**过早唤醒**。

**欺骗性唤醒**和**信号丢失**问题的规避方法：将等待线程对保护条件的判断，Objectwait\(\) 的调用放在相应对象所引导的临界区中的一个循环语句中即可。

### 上下文切换问题

#### 解决方法

1. 在保证程序正确性的前提下，使用 Object.notify 代替 Object.notifyAll.Object.notify 不会导致过早唤醒，因此减少了相应的上下文切换。
2. 通知线程在执行完 Object.notifyAll 之后尽快释放相应的内部锁。这样可以避免被唤醒的线程在 Object.wait 调用返回前再次申请相应的内部锁时，由于该锁尚未被通知线程释放而导致该线程被暂停（以等待再次获得锁的机会）。







