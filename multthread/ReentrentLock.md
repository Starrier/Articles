# ReentrantLock

主要使用 CAS + CLH 队列实现，支持公平锁和非公平锁，两者的实现类似

CAS：Compare and Swap ,比较并交换。CAS 有 3 个操作数，内存值，预期值 A,要修改的新值 B 。当且仅当预期值 A 和内存值 V 相同时，将内存值修改为 B，否则什么都不做。该操作是一个原子操作。 CAS 主要由 sum.misc.Unsafe 这个类通过 JNI 调用 CPU 底层指令实现。

CLH 队列： 带头结点的双向非循环队列

先通过 CAS 尝试获取锁，如果此时已经有线程占据了锁，那就加入 CLH 队列并且被挂起。当锁被释放之后，排在 CLH 队列队首的线程会被唤醒，然后 CAS 再次尝试获取这个锁，如果：

 - 非公平锁：如果同时还有另一个线程进来尝试获取，那么有可能会让这个线程抢先获取
 - 公平锁：如果同时还有另一个线程进来尝试获取，当它发现自己不是在队首的话，就会排到队尾，由队首的线程获取到锁。


非公平锁

在尝试获取🔒的时候，会先调用 nofairTryAcquire。如果装填为 0，表明此时无人占有锁。此时尝试进行 set，一旦成功，则成功占有锁。如果状态不为 0，再判断是否是当前线程获取到锁。如果是的话，将状态 +1，因为此时就是当前线程，所以不用 CAS。这也就是可重入锁的实现原理。