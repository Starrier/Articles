# final

### final：最终的，不可改变的

1. 修饰变量，为常量，值不可变
2. 修饰对象，值可变，引用不可变
3. 修饰方法，方法不可以重写
4. 修饰类，无子类，不可以被继承，更不能被重写

{% hint style="warning" %}
1. final 修饰的基本类型变量必须赋值，但只能赋值一次（可以在声明时显示初始化赋值，或者在初始化块中初始化赋值）
2. final 修饰的引用类型变量赋值之后，不能再指向其他对象！但是所引用对象的内部属性的值是可以改变的。
{% endhint %}

## **内部类去访问外部变量，为什么需要加final?**

题目有点问题，并不是所有的外部变量才加final,我们的内部类访问我们的成员变量就不需要加final,但是访问局部变量就必须要加final，因为方法（main方法）结束我们栈帧也就销毁了，但是我们内部类在堆中并没有被销毁，如果引用了成员变量，这时候被销毁了肯定是不行的，所以我们就需要成员变量设置为final，让其在方法（main方法）结束时不会被销毁。

### 修饰类

当用 final 修饰一个类，表明这个类不能被继承。也就是说，如果一个类你永远不会让它继承，就可以用 fianl 进行修饰。final 类中的成员变量可以根据需要设为 final，但要注意 final 类中的所有成员方法都被隐式指定为 final 方法。

在使用 final 修饰类，要注意谨慎选择，除非这个类真的在以后不会用来继承或者处于安全考虑，尽量不要将类设计成 final 类。

### 修饰方法

 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。

只有在明确想禁止该方法在子类中被覆盖的情况下，才将方法设置成 final。

### 修饰变量

对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象

#### 1. final 和普通变量

当 final 作用于类的成员变量时，成员变量（注意是类的成员变量，局部变量只需要保证在使用之前被初始化赋值即可）必须在定义时或者构造器中进行初始化赋值，而且final变量一旦被初始化赋值之后，就不能再被赋值了。

 当final变量是基本数据类型以及String类型时，如果在编译期间能知道它的确切值，则编译器会把它当做编译期常量使用。也就是说在用到该final变量的地方，相当于直接访问的这个常量，不需要在运行时确定。这种和C语言中的宏替换有点像。

#### 2. 被 final 修饰的变量可变么

**引用变量被 final 修饰后，虽然不能在指向其他对象，但是它指向的对象内容是可变的**  


#### 3. final 和 static

static 作用域成员变量用来表示只保存一份副本，而 final 作用是保证变量不可变。

4. 匿名内部类中使用的外部局部变量只能是 final 变量



























