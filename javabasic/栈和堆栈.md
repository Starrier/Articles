# 栈、堆、堆栈

 栈\(stack\)与堆\(heap\)都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。   
  
栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共 享，详见第3点。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要 在运行时动态分配内存，存取速度较慢。   
  
Java中的数据类型有两种。   
  
一种是基本类型\(primitive types\), 共有8种，即int, short, long, byte, float, double, boolean, char\(注意，并没有string的基本类型\)。这种类型的定义是通过诸如int a = 3; long b = 255L;的形式来定义的，称为自动变量。值得注意的是，自动变量存的是字面值，不是类的实例，即不是类的引用，这里并没有类的存在。如int a = 3; 这里的a是一个指向int类型的引用，指向3这个字面值。这些字面值的数据，由于大小可知，生存期可知\(这些字面值固定定义在某个程序块里面，程序块退出 后，字段值就消失了\)，出于追求速度的原因，就存在于栈中。   
  
　　另外，栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义：   
  
int a = 3;   
int b = 3;   
  
　　编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处 理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。   
  
　　特别注意的是，这种字面值的引用与类对象的引用不同。假定两个类对象的引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，那么另 一个对象引用变量也即刻反映出这个变化。相反，通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。如上例，我们定义完 a与b的值后，再令a=4；那么，b不会等于4，还是等于3。在编译器内部，遇到a=4；时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地 址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。   
  
　　另一种是包装类数据，如Integer, String, Double等将相应的基本数据类型包装起来的类。这些类数据全部存在于堆中，Java用new\(\)语句来显示地告诉编译器，在运行时才根据需要动态创 建，因此比较灵活，但缺点是要占用更多的时间。 4. String是一个特殊的包装类数据。即可以用String str = new String\("abc"\);的形式来创建，也可以用String str = "abc"；的形式来创建\(作为对比，在JDK 5.0之前，你从未见过Integer i = 3;的表达式，因为类与字面值是不能通用的，除了String。而在JDK 5.0中，这种表达式是可以的！因为编译器在后台进行Integer i = new Integer\(3\)的转换\)。前者是规范的类的创建过程，即在Java中，一切都是对象，而对象是类的实例，全部通过new\(\)的形式来创建。Java 中的有些类，如DateFormat类，可以通过该类的getInstance\(\)方法来返回一个新创建的类，似乎违反了此原则。其实不然。该类运用了单 例模式来返回类的实例，只不过这个实例是在该类内部通过new\(\)来创建的，而getInstance\(\)向外部隐藏了此细节。那为什么在String str = "abc"；中，并没有通过new\(\)来创建实例，是不是违反了上述原则？其实没有。   
  
　　5. 关于String str = "abc"的内部工作。Java内部将此语句转化为以下几个步骤：   
  
　　\(1\)先定义一个名为str的对String类的对象引用变量：String str；   
  
　　\(2\)在栈中查找有没有存放值为"abc"的地址，如果没有，则开辟一个存放字面值为"abc"的地址，接着创建一个新的String类的对象o，并 将o的字符串值指向这个地址，而且在栈中这个地址旁边记下这个引用的对象o。如果已经有了值为"abc"的地址，则查找对象o，并返回o的地址。   
  
　　\(3\)将str指向对象o的地址。   
  
　　值得注意的是，一般String类中字符串值都是直接存值的。但像String str = "abc"；这种场合下，其字符串值却是保存了一个指向存在栈中数据的引用！   
  
　　为了更好地说明这个问题，我们可以通过以下的几个代码进行验证。   
  
String str1 = "abc";   
String str2 = "abc";   
System.out.println\(str1==str2\); //true   
  
　　注意，我们这里并不用str1.equals\(str2\)；的方式，因为这将比较两个字符串的值是否相等。==号，根据JDK的说明，只有在两个引用都指向了同一个对象时才返回真值。而我们在这里要看的是，str1与str2是否都指向了同一个对象。   
结果说明，JVM创建了两个引用str1和str2，但只创建了一个对象，而且两个引用都指向了这个对象。   
  
　　我们再来更进一步，将以上代码改成：   
  
String str1 = "abc";   
String str2 = "abc";   
str1 = "bcd";   
System.out.println\(str1 + "," + str2\); //bcd, abc   
System.out.println\(str1==str2\); //false   
  
　　这就是说，赋值的变化导致了类对象引用的变化，str1指向了另外一个新对象！而str2仍旧指向原来的对象。上例中，当我们将str1的值改为"bcd"时，JVM发现在栈中没有存放该值的地址，便开辟了这个地址，并创建了一个新的对象，其字符串的值指向这个地址。   
  
　　事实上，String类被设计成为不可改变\(immutable\)的类。如果你要改变其值，可以，但JVM在运行时根据新值悄悄创建了一个新对象，然 后将这个对象的地址返回给原来类的引用。这个创建过程虽说是完全自动进行的，但它毕竟占用了更多的时间。在对时间要求比较敏感的环境中，会带有一定的不良 影响。   
  
　　再修改原来代码：   
  
String str1 = "abc";   
String str2 = "abc";   
  
str1 = "bcd";   
  
String str3 = str1;   
System.out.println\(str3\); //bcd   
  
String str4 = "bcd";   
System.out.println\(str1 == str4\); //true   
  
　　str3这个对象的引用直接指向str1所指向的对象\(注意，str3并没有创建新对象\)。当str1改完其值后，再创建一个String的引用 str4，并指向因str1修改值而创建的新的对象。可以发现，这回str4也没有创建新的对象，从而再次实现栈中数据的共享。   
  
　　我们再接着看以下的代码。   
  
String str1 = new String\("abc"\);   
String str2 = "abc";   
System.out.println\(str1==str2\); //false   
  
　　创建了两个引用。创建了两个对象。两个引用分别指向不同的两个对象。   
  
String str1 = "abc";   
String str2 = new String\("abc"\);   
System.out.println\(str1==str2\); //false   
  
　　创建了两个引用。创建了两个对象。两个引用分别指向不同的两个对象。   
  
　　以上两段代码说明，只要是用new\(\)来新建对象的，都会在堆中创建，而且其字符串是单独存值的，即使与栈中的数据相同，也不会与栈中的数据共享。   
  
　　6. 数据类型包装类的值不可修改。不仅仅是String类的值不可修改，所有的数据类型包装类都不能更改其内部的值。   
  
    7. 结论与建议：   
  
　　\(1\)我们在使用诸如String str = "abc"；的格式定义类时，总是想当然地认为，我们创建了String类的对象str。担心陷阱！对象可能并没有被创建！唯一可以肯定的是，指向 String类的引用被创建了。至于这个引用到底是否指向了一个新的对象，必须根据上下文来考虑，除非你通过new\(\)方法来显要地创建一个新的对象。因 此，更为准确的说法是，我们创建了一个指向String类的对象的引用变量str，这个对象引用变量指向了某个值为"abc"的String类。清醒地认 识到这一点对排除程序中难以发现的bug是很有帮助的。   
  
　　\(2\)使用String str = "abc"；的方式，可以在一定程度上提高程序的运行速度，因为JVM会自动根据栈中数据的实际情况来决定是否有必要创建新对象。而对于String str = new String\("abc"\)；的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。这个思想应该是 享元模式的思想，但JDK的内部在这里实现是否应用了这个模式，不得而知。   
  
　　\(3\)当比较包装类里面的数值是否相等时，用equals\(\)方法；当测试两个包装类的引用是否指向同一个对象时，用==。   
  
　　\(4\)由于String类的immutable性质，当String变量需要经常变换其值时，应该考虑使用StringBuffer类，以提高程序效率。   
  
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////   
  
栈\(stack\):是一个先进后出的数据结构,通常用于保存方法\(函数\)中的参数,局部变量.   
在java中,所有基本类型和引用类型都在栈中存储.栈中数据的生存空间一般在当前scopes内\(就是由{...}括起来的区域\).   
  
堆\(heap\):是一个可动态申请的内存空间\(其记录空闲内存空间的链表由操作系统维护\),C中的malloc语句所产生的内存空间就在堆中.   
在java中,所有使用new xxx\(\)构造出来的对象都在堆中存储,当垃圾回收器检测到某对象未被引用,则自动销毁该对象.所以,理论上说java中对象的生存空间是没有限制的,只要有引用类型指向它,则它就可以在任意地方被使用.   


#### 在JAVA中，有六个不同的地方可以存储数据： 

1.  寄存器（register）。这是最快的存储区，因为它位于不同于其他存储区的地方——处理器内部。但是寄存器的数量极其有限，所以寄存器由编译器根据需求进行分配。你不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象。 
2. 堆栈（stack）。位于通用RAM中，但通过它的“堆栈指针”可以从处理器哪里获得支持。堆栈指针若向下移动，则分配新的内存；若向上移动，则释放那些 内存。这是一种快速有效的分配存储方法，仅次于寄存器。创建程序时候，JAVA编译器必须知道存储在堆栈内所有数据的确切大小和生命周期，因为它必须生成 相应的代码，以便上下移动堆栈指针。这一约束限制了程序的灵活性，所以虽然某些JAVA数据存储在堆栈中——特别是对象引用，但是JAVA对象不存储其 中。 
3. 堆（heap）。一种通用性的内存池（也存在于RAM中），用于存放所以的JAVA对象。堆不同于堆栈的好处是：编译器不需要知道要从堆里分配多少存储区 域，也不必知道存储的数据在堆里存活多长时间。因此，在堆里分配存储有很大的灵活性。当你需要创建一个对象的时候，只需要new写一行简单的代码，当执行 这行代码时，会自动在堆里进行存储分配。当然，为这种灵活性必须要付出相应的代码。用堆进行存储分配比用堆栈进行存储存储需要更多的时间。 
4. 静态存储（static storage）。这里的“静态”是指“在固定的位置”。静态存储里存放程序运行时一直存在的数据。你可用关键字static来标识一个对象的特定元素是静态的，但JAVA对象本身从来不会存放在静态存储空间里。 
5. 常量存储（constant storage）。常量值通常直接存放在程序代码内部，这样做是安全的，因为它们永远不会被改变。有时，在嵌入式系统中，常量本身会和其他部分分割离开，所以在这种情况下，可以选择将其放在ROM中 
6. 非RAM存储。如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。  就速度来说，有如下关系：  寄存器 &lt; 堆栈 &lt; 堆 &lt; 其他 

#### 堆栈之间的关系：

#### 堆：

堆是heap，是所谓的动态内存，其中的内存在不需要时可以回收，以分配给新的内存请求，其内存中的数据是无序的，即先分配的和随后分配的内存并没有什么必然的位置关系，释放时也可以没有先后顺序。一般由使用者自由分配，malloc分配的就是堆，需要手动释放。

堆是全局的，堆栈是每个函数进入的时候分一小块，函数返回的时候就释放了，静态和全局变量，new 得到的变量，都放在堆中，局部变量放在堆栈中，所以函数返回，局部变量就全没了。 

#### 栈（堆栈）

就是 stack。实际上是只有一个出入口的队列，即后进先出（First In Last Out），先分配的内存必定后释放。一般由，由系统自动分配，存放存放函数的参数值，局部变量等，自动清除。 其实在实际应用中，栈多用来存储方法的调用。而对则用于对象的存储。 

JAVA中的基本类型，其实需要特殊对待。因为，在JAVA中，通过new创建的对象存储在“堆”中，所以用new 创建一个小的、简单的变量，如基本类型等，往往不是很有效。因此，在JAVA中，对于这些类型，采用了与C、C++相同的方法。也就是说，不用new 来创建，而是创建一个并非是“引用”的“自动”变量。这个变量拥有它的“值”，并置于堆栈中，因此更高效。   
因为基础差，所以面对的问题都很低级 

#### 问题一：

```java
String str1 = "abc"; 
String str2 = "abc"; 
System.out.println(str1==str2); //true 
```

#### 问题二：

```java
String str1 =new String ("abc"); 
String str2 =new String ("abc"); 
System.out.println(str1==str2); // false 
```

#### 问题三：

```java
String s1 = "ja"; 
String s2 = "va"; 
String s3 = "java"; 
String s4 = s1 + s2; 
System.out.println(s3 == s4);//false 
System.out.println(s3.equals(s4));//true 
```

  
  
Java 中的堆和栈   
Java把内存划分成两种：一种是栈内存，一种是堆内存。   
  
在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。   
  
   当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。   
  
   堆内存用来存放由new创建的对象和数组。   
  
   在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。   
  
   在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。   
  
   引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。   
  
具体的说：   
栈与堆都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。   
      Java的堆是一个运行时数据区,类的\(对象从中分配空间。这些对象通过new、newarray、anewarray和multianewarray等 指令建立，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时 动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。   
      栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类 型的变量（,int, short, long, byte, float, double, boolean, char）和对象句柄。   
      栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义：   
int a = 3;   
int b = 3；   
编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3。接着处理int b = 3；在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。这时，如果再令a=4；那么编译器 会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。要注意这 种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，因为这种情况a的修改并不会影响到b, 它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。   


```java
//String是一个特殊的包装类数据。可以用： 
String str = new String("abc"); 
String str = "abc";  
```

两种的形式来创建，第一种是用new\(\)来新建对象的，它会在存放于堆中。每调用一次就会创建一个新的对象。 

而第二种是先在栈中创建一个对String类的对象引用变量str，然后查找栈中有没有存放"abc"，如果没有，则将"abc"存放进栈，并令str指向”abc”，如果已经有”abc” 则直接令str指向“abc”。 

比较类里面的数值是否相等时，用equals\(\)方法；当测试两个包装类的引用是否指向同一个对象时，用 ==，下面用例子说明上面的理论。  

```java
String str1 = "abc"; 
String str2 = "abc"; 
System.out.println(str1==str2); //true 
```

两个字符串变量名指向同一个对象。

```java
String str1 =new String ("abc"); 
String str2 =new String ("abc"); 
System.out.println(str1==str2); // false 
```

用new的方式是生成不同的对象。每一次生成一个。 

 因此用第二种方式创建多个”abc”字符串,在内存中其实只存在一个对象而已. 这种写法有利与节省内存空间. 同时它可以在一定程度上提高程序的运行速度，因为JVM会自动根据栈中数据的实际情况来决定是否有必要创建新对象。而对于String str = new String\("abc"\)；的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。 

另一方面, 要注意: 我们在使用诸如String str = "abc"；的格式定义类时，总是想当然地认为，创建了String类的对象str。担心陷阱！对象可能并没有被创建！而可能只是指向一个先前已经创建的 对象。只有通过new\(\)方法才能保证每次都创建一个新的对象。由于 String 类的 immutable 性质，当 String 变量需要经常变换其值时，应该考虑使用 StringBuffer 类，以提高程序效率。 

