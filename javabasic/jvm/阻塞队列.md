#

## ArrayBlockingQueue

基于数组的阻塞队列实现，在 ArrayBlockingQueue 内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue 内部还保留两个整型变量，分别表示这队列头部和尾部在数组中的位置。

该队列在生产者放入数据和消费者获取数据，都是公共同一个锁对象，由此也意味着两者无法真正并行运行，这点有其不同与 LinkedBlockingQueue。在插入和删除元素时，不会产生或销毁任何额外的对象实例，而 LinkedBlockingQueue 会生产一个额外的 Node 对象。在长时间内需要高效并发处理大批量数据时，对于 GC 影响有区别。ArrayBlockingQueue 存在公平锁和非公平锁，默认是非公平锁。

##  LinkedBlockingQueue

基于链表的阻塞队列，同 ArrayListBlockingQueue，内部维持一个数据缓存队列（由链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。

如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。

## DelayQueue

DelayQueue 中的元素只有当指定的延迟时间到了，才能够从队列中获取该元素。DelayQueue 是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取操作（消费者）才会被阻塞。

DelayQueu 常用来管理一个超时未响应的链接队列。

## PriorityBlockingQueue

基于优先级的阻塞队列（优先级的判断通过构造函数传入的 Compator 对象来决定），但需要注意的是 PriorityBlockingQueue 并不会阻塞生产者，只会在没有数据可以消费时，阻塞消费者。因此使用时，生产者生产速度决不能快于消费者。否则，时间一长，会最终耗尽所有可用堆内存。在实现该队列时，内部控制线程同步的锁是公平锁。

## SynchronousQueue

一种无缓冲的等待队列。有公平锁和非公平锁。

- 公平锁：配合一个 FIFO 队列来阻塞多余的生产者和消费者。
- 非公平锁：配合一个 LIFO 队列来管理多余的生产者和消费者。如果生产者和消费者处理速度有差距，会出现饥渴。即，某些生产者或消费者的数据永远得不到处理。