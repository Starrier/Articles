---
title: mysql-type
date: 2019-02-22 22:09:59
tags: MySQL
index_img: ../post_img/mysql-type.jpeg
---

## MySQL 字段类型

MySQL 支持多种类型，大致分为：

 * 数值
 * 日期/时间
 * 字符串（字符）类型

### 数值类型

MySQL 的数值类型大致可以分为：整数；浮点数（小数）。许多不同的子类型对这些类别中的每一个都是可用的，每个子类型支持不同大小的数据，并且 MySQL 允许我们指定树脂字段中的值是否有正负之分（**`UNSIGNED`**）或用零填补（**`ZEROFILL`**）。

1 bit = 1 位； 1 字节 = 8 bit， 1 k = 1024 字节 

| 类型 | 大小 | 范围（有符号）| 范围（UNSIGNED）| 用途 |
| --- | --- | --- | --- | --- | ---|
| TINYINT| 1 字节 | (-128,127) | (0,255) | 小整数值 |
| SMALLINT | 2 字节 | (-32768,32767) | (0,65535) | 大整数值 |
| MEDIUMINT | 3 字节 | ( -8388608,8388607) | (0,16777215) | 大整数值 |
| INT(INTEGER) | 4 字节 | || 大数值 |
| BIGINT | 8 字节 | | | 极大整数值 |
| FLOAT | 4 字节 | | | 单精度浮点数值 |
| DOUBLE | 8 字节 | |  | 双精度浮点数值 |
| DECIMAL | 若 DECIMAL(M，D) 中，M > D,则为 M + 2，否则为 D + 2 | 依赖于 M 和 D 的值 | 依赖于 M 和 D 的值 | 小数值 |

#### INT

在 MySQL 中，支持 5 个主要的整数类型

 * TINYINT
 * SMALLINT
 * MEDIUMINT
 * INT 
 * BIGINT

这些类型在很大程度上是相同的，只是它们存储的值大小不同。MySQL 用可选的显示宽度指示器的形式对 SQL 标准进行扩展:

如，INT(6),6 即为其宽度指示器，它并不会影响 INT 列存储字段的大小，也就是说，**超过 6 位，它不会自动截取，依然会进行存储，只要没有超过字段本身可以存储的范围即可，只有超出了才会进行截取**；宽度指示器的作用在于该字段如果有 `ZEROFILL` 存在，未满足 6 位的部分就会用 0 进行填充。这样当从数据库中检索一个值时，可以把这个值加长到指定的长度。例如，指定一个字段类型为 INT(6)，就可以保证所包含数字少于 6 个的值从数据库中检索出时，能够自动地使用空格进行填充。 万一我们需要对一个字段存储一个超出许可范围的数字，MySQL 会根据允许范围最接近它的一段截短后再进行存储，还有一个比较特别的地方是，MySQL 会在不合规定的值插入表之前将其自动修改为 0。

#### UNSIGNED 和 ZEROFILL

`UNSIGNED` 修饰符规定字段只保存正值，即无符号，而 MySQL 字段默认是有符号的。因为不需要保证数字的正、负号，可以在存储时节约一个“位”的空间（即翻一倍）。从而增大这个字段可以存储的值范围。注意，这个修饰符要紧跟在数值类型之后。

`ZEROFILL` 修饰符规定 0 （不是空格）可以用来填补输出的值。使用这个修饰符可以阻止 MySQL 数据库存储负值，如果某列设置为 `ZEROFILL`，那它就自动 `UNSIGNED`。这个值要配合 `INT`、`TINYINT`、`SMALLINT`、`MIDUMINT` 等字段的宽度指示器来用；比如：`XX INT(6)`，如果没有 `ZEROFILL`，这个宽度指示器将没有任何意义（**测试前导 0 时，用黑窗口测试**）。

##### 为什么 MySQL 存储的值要分有符号和无符号

因为一个字节占 8 bit，1 bit 只有 0 和 1 两种可能，8 的 bit 有 2^8 = 256 中可能，也就是 0 ~ 256；但如果是有符号，就需要 1 bit 来存储这个负号，本来的 8 bit 剩下 7 bit，即 2^7 = 128，也就是 -128~127(正数部分包含 0)。

#### FLOAT DOUBLE 和 DECIMAL

MySQL 支持三个浮点类型。`FLOAT` 数值类型用于表示单精度浮点数值，而 `DOUBLE` 数值类型用于表示双精度浮点数值。与整数一样，这些类型也带有附加参数：一个显示宽度指示器和一个小数点指示器（必须要带有指示器，要不然会查不到结果，并且宽度指示器和 `XXint`类型的宽度指示器不同，这里会实际限制宽度）比如语句 `FLOAT(7,3)` 规定显示的值不会超过 7 位数字（包括小数位），小数点后面带有 3 位数字。对于小数点后面的位数超过允许范围的值，MySQL 会自动将它四舍五入为最接近它的值，再插入它。

DECIMAL 数据类型用于精度要求非常高的计算中，这种类型允许指定数值的精度和计算方法作为选择参数。精度在这里指为这个值保存的有效数字的总个数，而计算方法表示小数点后不超过 3 位。

`FLOAT` 类型在长度比较高，比如 `FLOAT(10,2`) 和 `DECIMAL(10,2)` 同时插入一个符合 `(10,2)` 宽度的数值，`FLOAT` 就会出现最后小数点存在误差值。

`UNSIGNED` 和 `ZEROFILL` 修饰符也可以被 `FLOAT` `DOUBLE` 和 `DECIMAl` 数据类型使用，并且效果与 `INT` 数据类型相同。

### 字符串类型

MySQL 提供了 8 个基本的字符串类型，可以存储的范围从简单的一个字符到巨大的文本块或二进制字符串数据。

1 个中文字符 2 字节，一个英文字符 1 字节。

| 类型 | 大小 | 用途 |
| --- | --- | --- |
| CHAR | 0 ~ 255 字节 | 定长字符串 |
| VARCHAR | 0 ~ 255 字节 | 变长字符串 |
| TINYBLOB | 0 ~ 255 字节 | 不超过 255 个字符的二进制字符串 |
| TINYTEXT | 0 ~ 255 字节 | 短文本字符串 |
| BLOB | 0 ~ 65535 字节 = 64 k | 二进制形式的长文本数据 |
| TEXT | 0 ~ 65535 字节 | 长文本数据 |
| MEDIUMBLOB | | 二进制形式的中等长度文本数据 |
| MEDIUMTEXT | | 中等长度文本数据 |
| LOGNGBLOB | | 二进制形式的极大文本数据 |
| LONGTEXT | | 极大文本数据 |

#### BINARY 

BINARY 不是函数，而是类型转换运算符，它用来强制它后面字符串为一个二进制字符串，可以理解为在字符串比较的时候区分大小写。

``` sql
--- COM 输出 0， COM2 输出 1
SELECT BINARY 'ABCD' = 'abcd' as COM,'ABCD' = 'abcd' as COM2;
```

#### CHAR 和 VARCHAR 类型

`CHAR` 类型用于定长字符串，并且必须在圆括号内用一个大小修饰符来定义。这个大小修饰符的范围是 0 ~ 255。比指定长度达的值将被截短，而比指定长度小的值将会用空格填补。`CHAR` 类型可以使用 `BINARY` 修饰符。当用于比较运算时，这个修饰符使 `CHAR` 以二进制方式参与运算，而不是以传统的区分大小写的方式。

`VARCHAR` 是一种可变长度的字符串类型，并且也必须带有一个范围在 0 ~ 255 之间的指示器。

`CHAR` 和 `VARCHAR` 的区别在于 MySQL 处理指示器的方式：`CHAR` 把这个大小视为值的大小，长度不足的情况下就用空格补足。而 `VARCHAR` 类型把它视为最大值并且只使用存储字符串实际需要的长度（增加一个额外字节来存储字符串本身的长度）来存储值。所以短于指示器长度的 `VARCHAR` 类型不会被空格填补，但长于指示器的值仍然会被截短。

因为 `VARCHAR` 类型可以根据实际内容动态改变存储值的长度，所以在不能确定字段需要多少字符时使用 `VARCHAR` 类型可以大大地节约磁盘空间、提高存储效率。但如果确切知道字符串长度,比如就在 50~55 之间,那就用 `CHAR` 因为 `CHAR` 类型由于本身定长的特性使其性能要高于 `VARCHAR`;

`VARCHAR` 类型在使用 `BINARY` 修饰符时与 `CHAR` 类型完全相同。

#### TEXT 和 BLOB 类型

对于字段长度要求超过 255 个的情况下，MySQL 提供了 `TEXT` 和 `BLOB` 两种类型。根据存储数据的大小，它们都有不同的子类型。这些大型的数据用于存储文本块或图像、声音文件等二进制数据类型。

`TEXT` 和 `BLOB` 类型在分类和比较上存在区别。`BLOB` 类型区分大小写，而 `TEXT` 不区分大小写。大小修饰符不用于各种 `BLOB` 和 `TEXT` 子类型。比指定类型支持的最大范围大的值将被自动截短。

### 时间类型

| 类型 | 大小 | 范围 | 格式 | 用途 |
| --- | --- | --- | --- | --- |
| DATA | 3 | | YYYY-MM-DD | 日期值 |
| TIME | 3 |  | HH:MM:SS | 时间值或持续时间 |
| YEAR | 1 | | YYYY | 年份值 |
| DATETIME | 8 | | YYYY-MM-DD HH:MM:SS | 混合日期和是时间值 |
|TIMESTAMP | 8 | | YYYYMMDD HHMMSS| 混合日期和时间值，时间戳|


#### `DATE`、`TIME` 和 `YEAR` 类型

MySQL 用 `DATE` 和 `YEAR` 类型存储简单的日期值，使用 `TIME` 类型存储时间值。这些类型可以描述为字符串或不带分隔符的整数序列。如果描述为字符串，`DATE` 类型的值应该使用连字号作为分隔符分开，而 `TIME` 类型的值应该使用冒号作为分隔符分开。

需要注意的是，没有冒号分隔符的 `TIME` 类型值，将会被 MySQL 理解为持续的时间，而不是时间戳。

MySQL 还对日期的年份中的两个数字的值，或是 SQL 语句中为 `YEAR` 类型输入的两个数字进行最大限度的通译。因为所有 `YEAR` 类型的值必须用 `4 `个数字存储。MySQL 试图将 `2` 个数字的年份转换为 `4 ` 个数字的值。把在 00-69 范围内的值转换到 2000-2069 范围内。把 70-99 范围内的值转换到 1970-1979 之内。如果 MySQL 自动转换后的值并不符合我们的需要，请输入 `4` 个数字表示的年份。

#### `DATETIME` 和 `TIMESTAMP` 类型

除了日期和时间数据类型，MySQL 还支持 `DATETIME` 和 `TIMESTAMP` 这两种混合类型。它们可以把日期和时间作为单个的值进行存储。这两种类型通常用于自动存储包含当前日期和时间的时间戳，并可在需要执行大量数据库事务和需要建立一个调试和审查用途的审计跟踪的应用程序中发挥良好作用。

如果我们对 `TIMESTAMP` 类型的字段没有明确赋值，或是被赋与了 `null` 值。MySQL 会自动使用系统当前的日期和时间来填充它。

#### 复合类型

MySQL 还支持两种复合数据类型 `ENUM` 和 `SET`，它们扩展了 SQL 规范。虽然这些类型在技术上是字符串类型，但是可以被视为不同的数据类型。一个 `ENUM` 类型只允许从一个集合中取得一个值；而 `SET` 类型允许从一个集合中取得任意多个值。

#### `ENUM` 类型

`ENUM` 类型因为只允许在集合中取得一个值，有点类似于单选项。在处理相互排拆的数据时容易让人理解，比如人类的性别。`ENUM` 类型字段可以从集合中取得一个值或使用 `null` 值，除此之外的输入将会使 MySQL 在这个字段中插入一个空字符串。另外如果插入值的大小写与集合中值的大小写不匹配，MySQL 会自动使用插入值的大小写转换成与集合中大小写一致的值。

`ENUM` 类型在系统内部可以存储为数字，并且从 `1` 开始用数字做索引。一个 `ENUM` 类型最多可以包含 65536 个元素，其中一个元素被 MySQL 保留，用来存储错误信息，这个错误值用索引 `0` 或者一个空字符串表示。

MySQL 认为 `ENUM` 类型集合中出现的值是合法输入，除此之外其它任何输入都将失败。这说明通过搜索包含空字符串或对应数字索引为 `0` 的行就可以很容易地找到错误记录的位置。

#### `SET` 类型

`SET` 类型与 `ENUM` 类型相似但不相同。`SET` 类型可以从预定义的集合中取得任意数量的值。并且与 `ENUM` 类型相同的是任何试图在 `SET` 类型字段中插入非预定义的值都会使 MySQL 插入一个空字符串。如果插入一个即有合法的元素又有非法的元素的记录，MySQL 将会保留合法的元素，除去非法的元素。

一个 `SET` 类型最多可以包含 `64` 项元素。还去除了重复的元素，所以 `SET` 类型中不可能包含两个相同的元素。
希望从 `SET` 类型字段中找出非法的记录只需查找包含空字符串或二进制值为 `0` 的行。

### 字段类型总结

虽然上面列出了很多字段类型,但最常用也就是 `varchar(255)`,`char(255)`,`text`,`tinyint(4)`,`smallint(6)`,`mediumint`,`int(11)` 几种。
复合类型我们一般用 `tinyint`,更快的时间更省的空间以及更容易扩展
关于手机号，推荐用 `char(11)`,`char(11)` 在查询上更有效率，因为手机号是一个活跃字段参与逻辑会很多。
一些常用字段举例

```sql
姓名：char(20)
价格：DECIMAL(7, 3)
产品序列号：SMALLINT(5) unsigned
文章内容: TEXT
MD5: CHAR(32)
ip: char(15)
time: int(10)
email char(32)
```

### 合理地选择数据类型

 1. 选择合理范围内最小的

 我们应该选择最小的范围值，因为这样可以大大减少磁盘 IO 读写的开销，减少内存占用，减少 CPU 的占用率。

 2. 选择相对简单的数据类型

 数字类型相对字符串类型要简单的多，尤其是在比较运算时，所以我们应该选择最简单的数据类型，比如在保存时间时，因为 PHP 可以处理良好的 LINUX 时间戳，所以我们可以将日期存为 `INT(10)` 会方便、合适、快速地多。

 3. 不要使用 `NULL`

 MyySQL 对 `NULL` 字段索引优化不友好，同时在保存与处理 `NULL` 类形时，也会做更多的工作，所以从效率上来说，不建议用过多的 `NULL`。有些值他确实有可能没有值，怎么办呢？解决方法是数值弄用整数 0，字符串用空来定义默认值即可。

 4. 字符串类型的使用

 字符串数据类型是一个万能数据类型，可以储存数值、字符串、日期等。保存数值类型最好不要用字符串数据类型，这样存储的空间显然是会更大，而且在排序时字符串的 9 是大于 22 的，其实如果进行运算 mysql 会将字符串转换为数值类型，大大降低效果，而且这种转换是不会走原有的索引的。如果明确数据在一个完整的集合中如男，女，那么可以使用 `set` 或 `enum` 数据类型，这种数据类型在运算及储存时以数值方式操作，所以效率要比字符串更好，同时空间占用更少。

 5. `VARCHAR` 与 `CHAR`

 `VARCHAR` 是可变长度字符串类型，那么即然长度是可变的就会使用 1，2 个字节来保存字符的长度，如果长度在 255 内使用 1 个字节来保存字符长度，否则使用 2 个字符来保存长度。由于 `varchar` 是根据储存的值来保存数据，所以可以大大节约磁盘空间。

 如果数据经常被执行更新操作，由于 `VARCHAR` 是根据内容来进行储存的，所以 mysql 将做更多的工作来完成更新操作，如果新数据长度大于老数据长度一些存储引擎会进行拆分操作处理。同时 `varchar` 会完全保留内部所有数据，最典型的说明就是尾部的空格。

 `CHAR` 固定长度的字符串保存类型，`CHAR` 会去掉尾部的空格。在数据长度相近时使用 `char` 类型比较合适，比如 md5 加密的密码用户名等。如果数据经常进行更新修改操作，那么 `CHAR` 更好些，因为 `char` 长度固定，性能上要快。

 6. 数值类型的选择
  
 数值数据类型要比字符串执行更快，区间小的数据类型占用空间更少，处理速度更快，如 `tinyint` 可比 `bigint` 要快的多.选择数据类型时要考虑内容长度，比如是保存毫米单位还是米而选择不同的数值类型

 7. 整数

 整数类型很多比如 `tinyint`、`int`、`smallint`、`bigint` 等，那么我们要根据自己需要存储的数据长度决定使用的类型，同时 `tinyint(10)` 与 `tinyint(100)` 在储存与计算上并无任何差别，区别只是显示层面上，但是我们也要选择适合合适的数据类型长度。可以通过指定 `zerofill` 属性查看显示时区别。

 8. 浮点数与精度数值

 浮点数 `float` 在储存空间及运行效率上要优于精度数值类型 `decimal`，但 `float` 与 `double` 会有舍入错误而 `decimal` 则可以提供更加准确的小数级精确运算不会有错误产生计算更精确，适用于金融类型数据的存储。