---
title: fin-series
date: 2019-02-17 21:29:23
tags: Java
index_img: ../post_img/fin-series.jpeg
---

## fin-series

### final

final作为对象成员存在时，必须初始化；但是，如果不初始化，也可以在类的构造函数中初始,即必须满足以下条件之一：

 1. 在构造函数中赋值
 2. 初始化赋值

因为java允许将数据成员声明为final，却不赋初值。但是，blank finals必须在使用之前初始化，且必须在构造函数中初始化  

### finally

 1. finally 块一定会执行，无论是否 try…catch。
 2. finally 前有 return，会先执行 return 语句，并保存下来，再执行 finally 块，最后 return。
 3. finally 前有 return、finally 块中也有 return，先执行前面的 return，保存下来，再执行 finally的 return，覆盖之前的结果，并返回。
 4. 在 try-catch 中，执行到 system.exit(0) 直接退出程序。

### finalize()

之所以要使用 finalize()，是存在着垃圾回收器不能处理的特殊情况。假定你的对象（并非使用new方法）获得了一块“特殊”的内存区域，由于垃圾回收器只知道那些显示地经由new分配的内存空间，所以它不知道该如何释放这块“特殊”的内存区域，那么这个时候java允许在类中定义一个由finalize()方法。

特殊的区域例如：

 1. 由于在分配内存的时候可能采用了类似 C 语言的做法，而非 JAVA 通常的 new 方法。这种情况主要发生在 native method 中，比如 native method 调用了 C/C++ 方法 `malloc()` 函数系列来分配存储空间，但是除非调用 `free()` 函数，否则这些内存空间将不会得到释放，那么这个时候就可能造成内存泄漏。但是由于 `free()` 方法是在 C/C++ 中的函数，所以 `finalize()` 中可以用本地方法来调用它。以释放这些“特殊”的内存空间。
 2. 又或者打开的文件资源，这些资源不属于垃圾回收器的回收范围。

换言之，`finalize()` 的主要用途是释放一些其他做法开辟的内存空间，以及做一些清理工作。因为在`JAVA`中并没有提供像“析构”函数或者类似概念的函数，要做一些类似清理工作的时候，必须自己动手创建一个执行清理工作的普通方法，也就是 override Object 这个类中的 `finalize()` 方法。例如，假设某一个对象在创建过程中会将自己绘制到屏幕上，如果不是明确地从屏幕上将其擦出，它可能永远都不会被清理。如果在 `finalize()` 加入某一种擦除功能，当 GC 工作时，`finalize()` 得到了调用，图像就会被擦除。要是 GC 没有发生，那么这个图像就会被一直保存下来。

一旦垃圾回收器准备好释放对象占用的存储空间，首先会去调用 `finalize()` 方法进行一些必要的清理工作。只有到下一次再进行垃圾回收动作的时候，才会真正释放这个对象所占用的内存空间。

在普通的清除工作中，为清除一个对象，那个对象的用户必须在希望进行清除的地点调用一个清除方法。这与 C++ **析构函数**的概念稍有抵触。在 C++ 中，所有对象都会破坏（清除）。或者换句话说，所有对象都"**应该**"破坏。若将 C++ 对象创建成一个本地对象，比如在堆栈中创建（在 Java 中是不可能的，Java 都在堆中），那么清除或破坏工作就会在"结束花括号"所代表的、创建这个对象的作用域的末尾进行。若对象是用 new 创建的（类似于 Java），那么当程序员调用 C++ 的 `delete` 命令时（Java 没有这个命令），就会调用相应的析构函数。若程序员忘记了，那么永远不会调用析构函数，我们最终得到的将是一个内存"漏洞"，另外还包括对象的其他部分永远不会得到清除。

相反，Java 不允许我们创建本地（局部）对象 —— 无论如何都要使用 new。但在 Java 中，没有 "`delete`" 命令来释放对象，因为垃圾回收器会帮助我们自动释放存储空间。所以如果站在比较简化的立场，我们可以说正是由于存在垃圾回收机制，所以 Java 没有析构函数。然而，随着以后学习的深入，就会知道垃圾收集器的存在并不能完全消除对析构函数的需要，或者说不能消除对析构函数代表的那种机制的需要（原因见下一段。另外 `finalize()`函数是在垃圾回收器准备释放对象占用的存储空间的时候被调用的，绝对不能直接调用`finalize()`，所以应尽量避免用它）。若希望执行除释放存储空间之外的其他某种形式的清除工作，仍然必须调用 Java 中的一个方法。它等价于 C++ 的析构函数，只是没后者方便。

在 C++ 中所有的对象运用 `delete()` 一定会被销毁，而 JAVA 里的对象并非总会被垃圾回收器回收:

 1. 对象可能不被垃圾回收，
 2. 垃圾回收并不等于“析构”，
 3. 垃圾回收只与内存有关。也就是说，如果一个对象不再被使用，是不是要在 `finalize()` 中释放这个对象中含有的其它对象呢？不是的。因为无论对象是如何创建的，垃圾回收器都会负责释放那些对象占有的内存。