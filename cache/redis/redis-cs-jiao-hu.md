# Redis - C/S 交互

## 串行的请求/响应模式

1. 每一次请求的发送都依赖于上一次请求的相应结果完全接收，同一个连接的每秒吞吐量低。
2. redis 对单个请求的处理时间通常比局域网的延迟小一个数量级。所以串行模式下，单链接的大部分时间都处于网络等待。

## 双工的请求/响应模式

1. 适用于批量的独立写入操作。即可将请求数据批量发送到服务器，再批量地从服务器连接的字节流中一次读取每个响应数据，减少了网络延迟，所以单连接吞吐量较串行会提高一个数量级

## 原子化的批量请求/响应模式（事务）

1. 客户端通过和redis服务器两阶段的交互做到批量命令原子执行的事务效果：入队操作（即服务器端先将客户端发送过来的连接对象暂存在请求队列中）和执行阶段（依次执行请求队列中的所有请求）
2. 一个连接的请求在执行批量请求的过程中，不会执行其他客户端的请求
3. redis的事务不是一致的，没有回滚机制。如果中途失败，则返回错误信息，但已经成功执行的命令不会回滚
4. 事务里面有可能会带有读操作作为条件，由于批量请求只会先入队列，再批量一起执行，所以一般读操作不会跟批量写请求一起执行，这时候就有可能会导致批量写之前和之后读到的数据不一致，这种可以通过乐观锁的可串行化来解决，redis通过watch机制实现乐观锁。具体实现过程看下一题

##  发布/订阅模式

1. 发布端和订阅者通过channel关联
2. channel的订阅关系，维护在reids实例级别，独立于redisDB的key-value体系。所有的channel都由一个map维护，键是channel的名字，value是它所有订阅者client的指针链表

## 脚本化的批量执行（脚本模式）

