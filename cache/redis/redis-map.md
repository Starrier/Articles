# Redis - map

map 又叫 hash。map 内部的 key 和 value 不能在嵌套 map 了，只能是 String 类型：整型、浮点型、字符串

map 主要由 hashtable 和 ziplist 两种承载方式实现，对于数据量较小的 map，采用 ziplist 实现。

hashtable 的内部结构

1.  主要分为三层，自底向上分别是 dictEntry、dictht、dict
2. dictEntry 管理一个 K-V 对，同时保留同一个桶中相邻元素的指针，一次维护 hash 桶的内部链
3. dictht 维护 hash 表的所有桶链
4. dict：当 dictht 需要扩容时，用于管理 dictch 的迁移
5. 哈希表的核心结构是 dictht，它的 table 字段维护着 hash 桶，它是一个数组，每个元素指向桶的第一个元素（dictEntry）
6. set 值流程：先通过 MurmurHash 算法，求出 key 的 hash 值，再对桶的个数去摸，得到 key 对应的桶，再进入桶中，遍历全部 entry，判定是否已有相同的 key，如果没有，则将新 key 对应的键值对插入到桶头，并且更新 dictht 的 used 数量，used 表示 哈是表中已经存了多少元素。由于每次插入都要遍历 hash 桶中的全部 entry，所以当桶中 entry 很多时，性能会线性下降。
7. 扩容:通过负载因子判定是否需要增加桶数，负载因子 = 哈希表中已经有元素/哈希桶数的比值。有两个阀值，小于 1 一定不扩容，大于 5 一定扩容。扩容时新的桶数目是现有桶的 2 m 倍。
8. 缩容：负载因子的阀值是 0.1
9. 扩容缩容通过新建 hash 表的方式实现。即扩容时，会并存两个 hash 表，一个是原表，一个是目标表。通过将原表的桶逐步迁移到目标表，以数据迁移的方式实现扩容，迁移完成后目标表覆盖原表。迁移过程中，首先访问原表， 如果发现key对应的源表桶已完成迁移，则重新访问目标表，否则在源表中操作
10. redis是单线程处理请求，迁移和访问的请求在相同线程内进行，所以不会存在并发性问题

