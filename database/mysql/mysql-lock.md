# MySQL - lock

### 有两种类型的锁

1. 内部锁：MySQL 在自身服务器内部执行内部锁，以管理多个会话对表内容的争用。
2. 外部锁：MySQL 为客户会话提供选项来显式地获取表锁，以阻止其他会话访问表。

### 内部锁

1. 行级锁：行级锁是细粒度的，只有被访问的行会被锁定。这允许通过多个会话同时进行写访问，使其适用于多用户、高度并发和 OLTP 的应用程序。只有 InnoDB 支持行级锁。
2. 表级锁：MySQL 对 MyISAM、 MEMORY、 和 MERGE 表使用表级锁，一次只允许一个会话更新这些表。这种锁定级别使得这些存储引擎更适合用于只读的或以读取操作为主的或单用户的应用程序。

### 外部锁

可以用 LOCK TABLE 和 UNLOCK TABLES 语句来控制锁定

READ 和 WRITE 的表锁定解释如下：

READ：当一个表被锁定为 READ 时，多个会话可以从表中读取数据而不需要获取锁。此外，多个会话可以在同一个表上获得锁，这就是为什么 READ 锁也被称为共享锁。当 READ 锁被保持时，没有会话可以将数据写入表格中（包括持有该锁的会话）。如果有任何写入尝试，该操作将处于等待状态，知道 READ 锁被释放。

WRITE：当一个表被锁定为 WRITE 时，除持有该锁的会话之外，其他任何会话都不能读取或向表中写入数据。除非现有锁被释放，否则其他任何会话都不能获得任何锁。这就是为什么 WRITE 锁被称为排他锁。如果有任何读取/写入尝试，该操作将处于等待状态，知道 WRITE 锁被释放。

当执行 UNLOCK TABLES 语句时或当前会话终止时，所有锁都会被释放。

锁定表的语法：

```sql
mysql> LOCK TABLES table_name [READ | WRITE]
```

释放表

```sql
mysql> UNLOCK TABLES;
```

要锁定所有数据库中的所有表，可以使用：（在获取数据库的一致快照时需要使用该语句，它会冻结对数据库的所有写入操作）

```sql
mysql> FLUSH TABLES WITH READ LOCK
```

### 锁队列

除了共享锁（一个表可以有多个共享锁）之外，没有两个锁可以一起加在一个表上。如果一个表已经有一个共享锁，此时有一个排他锁要进来，那么它蒋被保留在队列中，直到共享锁被释放。当排他锁在队列中时，所有后续的共享锁也会被阻塞并保留在队列中。

当 InnoDB 从表中读取/写入数据时会获取元数据锁。如果第二个事务请求 WRITE LOCK，该事物将被保留在队列中，直到第一个事务完成。如果第三个事务想要读取数据，就必须等待第二个事务完成。

