# MySQL 引擎

![Version 5.7.18](../../.gitbook/assets/mysqlenginers.png)

 关系数据库表是用于存储和组织信息的数据结构，可以将表理解为由行和列组成的表格，类似于Excel的电子表格的形式。有的表简单，有的表复杂，有的表根本不用来存储任何长期的数据，有的表读取时非常快，但是插入数据时去很差；而我们在实际开发过程中，就可能需要各种各样的表，不同的表，就意味着存储不同类型的数据，数据的处理上也会存在着差异，那么。对于MySQL来说，它提供了很多种类型的存储引擎，我们可以根据对数据处理的需求，选择不同的存储引擎，从而最大限度的利用MySQL强大的功能。这篇博文将总结和分析各个引擎的特点，以及适用场合，并不会纠结于更深层次的东西。我的学习方法是先学会用，懂得怎么用，再去知道到底是如何能用的。下面就对MySQL支持的存储引擎进行简单的介绍。

## 如何选用合适的存储引擎

1. 是否需要支持事务
2. 是否需要使用热备
3. 是否需要外键支持
4. 奔溃恢复：能否接受奔溃

## MylSAM

它不支持事务，也不支持外键，但是访问速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用基本都可以使用这个引擎来创建表。



该引擎基于ISAM数据库引擎，除了提供ISAM里所没有的索引和字段管理等大量功能，MyISAM还使用一种表格锁定的机制来优化多个并发的读写操作，但是需要经常运行OPTIMIZE TABLE命令，来恢复被更新机制所浪费的空间，否则碎片也会随之增加，最终影响数据访问性能。MyISAM还有一些有用的扩展，例如用来修复数据库文件的MyISAMChk工具和用来恢复浪费空间的 MyISAMPack工具。MyISAM强调了快速读取操作，主要用于高负载的select，这可能也是MySQL深受Web开发的主要原因：在Web开发中进行的大量数据操作都是读取操作，所以大多数虚拟主机提供商和Internet平台提供商（Internet Presence Provider，IPP）只允许使用MyISAM格式。

每个MyISAM在磁盘上存储成3个文件，其中文件名和表名都相同，但是扩展名分别为：

* .frm\(存储表定义\)
* MYD\(MYData，存储数据\)
* MYI\(MYIndex，存储索引\)

　　数据文件和索引文件可以放置在不同的目录，平均分配IO，获取更快的速度。要指定数据文件和索引文件的路径，需要在创建表的时候通过DATA DIRECTORY和INDEX DIRECTORY语句指定，文件路径需要使用绝对路径。

　　每个MyISAM表都有一个标志，服务器或myisamchk程序在检查MyISAM数据表时会对这个标志进行设置。MyISAM表还有一个标志用来表明该数据表在上次使用后是不是被正常的关闭了。如果服务器以为当机或崩溃，这个标志可以用来判断数据表是否需要检查和修复。如果想让这种检查自动进行，可以在启动服务器时使用--myisam-recover现象。这会让服务器在每次打开一个MyISAM数据表是自动检查数据表的标志并进行必要的修复处理。MyISAM类型的表可能会损坏，可以使用CHECK TABLE语句来检查MyISAM表的健康，并用REPAIR TABLE语句修复一个损坏到MyISAM表。  
　　MyISAM的表还支持3种不同的存储格式：

* 静态（固定长度）表
* 动态表
* 压缩表

静态型：指定义的表列的大小是固定（即不含有：xblob、xtext、varchar等长度可变的数据类型），这样MySQL就会自动使用静态MyISAM格式。使用静态格式的表的性能比较高，因为在维护和访问以预定格式存储数据时需要的开销很低；但这种高性能是以空间为代价换来的，因为在定义的时候是固定的，所以不管列中的值有多大，都会以最大值为准，占据了整个空间。 动态型：如果列（即使只有一列）定义为动态的（xblob, xtext, varchar等数据类型），这时MyISAM就自动使用动态型，虽然动态型的表占用了比静态型表较少的空间，但带来了性能的降低，因为如果某个字段的内容发生改变则其位置很可能需要移动，这样就会导致碎片的产生，随着数据变化的增多，碎片也随之增加，数据访问性能会随之降低。 对于因碎片增加而降低数据访问性这个问题，有两种解决办法： a、尽可能使用静态数据类型； b、经常使用optimize table table\_name语句整理表的碎片，恢复由于表数据的更新和删除导致的空间丢失。如果存储引擎不支持 optimize table table\_name则可以转储并 重新加载数据，这样也可以减少碎片；

压缩型：如果在数据库中创建在整个生命周期内只读的表，则应该使用 MyISAM 的压缩型来减少空间的占用。

　　其中静态表是默认的存储格式。静态表中的字段都是非变长字段，这样每个记录都是固定长度的，这种存储方式的优点是存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多。静态表在数据存储时会根据列定义的宽度定义补足空格，但是在访问的时候并不会得到这些空格，这些空格在返回给应用之前已经去掉。同时需要注意：在某些情况下可能需要返回字段后的空格，而使用这种格式时后面到空格会被自动处理掉。  
　　动态表包含变长字段，记录不是固定长度的，这样存储的优点是占用空间较少，但是频繁到更新删除记录会产生碎片，需要定期执行OPTIMIZE TABLE语句或myisamchk -r命令来改善性能，并且出现故障的时候恢复相对比较困难。  
　　压缩表由myisamchk工具创建，占据非常小的空间，因为每条记录都是被单独压缩的，所以只有非常小的访问开支。 

MyISAM是独立于操作系统的，这说明可以轻松地将其从windows服务器移植到Linux服务器；每当我们建立一个MyISAM引擎的表时，就会在本地磁盘上建立三个文件，文件名就是表名，例如建立一个MyISAM引擎的tb\_Demo表，就会生成以下三个文件：

文件名 意义 tb\_demo.frm 存储表定义 tb\_demo.MYD 存储数据 tb\_demo.MYI 存储索引 不适用场景：MyISAM表无法处理事务，这就意味着有事务处理需求的表，不能使用MyISAM存储引擎。 适用场景：

* 选择密集型的表。MyISAM存储引擎在筛选大量数据时非常迅速，这是他最突出的优点 
* 插入密集型的表。MyISAM的并发插入特性允许同时选择和插入数据。例如：MyISAM存储引擎很适合管理邮件或者web服务器日志数据。

## InnoDB

{% hint style="warning" %}
相比 MyISAM，InnoDB 写的处理效率差一点，并会占用更多的磁盘空间来保留数据和索引。
{% endhint %}

 InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。  
_1\)自动增长列：_  
　　InnoDB表的自动增长列可以手工插入，但是插入的如果是空或0，则实际插入到则是自动增长后到值。可以通过"ALTER TABLE...AUTO\_INCREMENT=n;"语句强制设置自动增长值的起始值，默认为1，但是该强制到默认值是保存在内存中，数据库重启后该值将会丢失。可以使用LAST\_INSERT\_ID\(\)查询当前线程最后插入记录使用的值。如果一次插入多条记录，那么返回的是第一条记录使用的自动增长值。  
对于InnoDB表，自动增长列必须是索引。如果是组合索引，也必须是组合索引的第一列，但是对于MyISAM表，自动增长列可以是组合索引的其他列，这样插入记录后，自动增长列是按照组合索引到前面几列排序后递增的。  
_2\)外键约束：_  
　　**MySQL支持外键的存储引擎只有InnoDB**，在创建外键的时候，父表必须有对应的索引，子表在创建外键的时候也会自动创建对应的索引。  
      在创建索引的时候，可以指定在删除、更新父表时，对子表进行的相应操作，包括restrict、cascade、set null和no action。其中restrict和no action相同，是指限制在子表有关联的情况下，父表不能更新；casecade表示父表在更新或删除时，更新或者删除子表对应的记录；set null 则表示父表在更新或者删除的时候，子表对应的字段被set null。  
　　当某个表被其它表创建了外键参照，那么该表对应的索引或主键被禁止删除。  
　　可以使用set foreign\_key\_checks=0;临时关闭外键约束，set foreign\_key\_checks=1;打开约束。

##  **MEMORY（HEAP）**

memory使用存在内存中的内容来创建表。每个MEMORY表实际对应一个磁盘文件，格式是.frm。MEMORY类型的表访问非常快，因为它到数据是放在内存中的，并且默认使用HASH索引，但是一旦服务器关闭，表中的数据就会丢失，但表还会继续存在。  
      默认情况下，memory数据表使用散列索引，利用这种索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了。因此，散列索引值适合使用在"="和"&lt;=&gt;"的操作符中，不适合使用在"&lt;"或"&gt;"操作符中，也同样不适合用在order by字句里。如果确实要使用"&lt;"或"&gt;"或betwen操作符，可以使用btree索引来加快速度。  
　　存储在MEMORY数据表里的数据行使用的是长度不变的格式，因此加快处理速度，这意味着不能使用BLOB和TEXT这样的长度可变的数据类型。VARCHAR是一种长度可变的类型，但因为它在MySQL内部当作长度固定不变的CHAR类型，所以可以使用。

```sql
create table tab_memory engine=memory ;
select id,name,age,addr 
from  man order by id;
```

　　使用USING HASH/BTREE来指定特定到索引。

```sql
create index mem_hash using hash on tab_memory(city_id);
```

　　在启动MySQL服务的时候使用--init-file选项，把insert into...select或load data infile 这样的语句放入到这个文件中，就可以在服务启动时从持久稳固的数据源中装载表。  
　　服务器需要足够的内存来维持所在的在同一时间使用的MEMORY表，当不再使用MEMORY表时，要释放MEMORY表所占用的内存，应该执行DELETE FROM或truncate table或者删除整个表。  
　　每个MEMORY表中放置到数据量的大小，受到max\_heap\_table\_size系统变量的约束，这个系统变量的初始值是16M，同时在创建MEMORY表时可以使用MAX\_ROWS子句来指定表中的最大行数。

## ARCHIVE

Archive+是归档的意思，在归档之后很多高级功能就不再支持了，仅仅支持最基本的插入和查询两种功能。MySQL5.5版以前，Archive是不支持索引，但是在MySQL5.5以后的版本中就开始支持索引了

Archive拥有很好的压缩机制，它使用zlib压缩库，在记录被请求时会实时压缩，所以它经常被用来当做仓库使用

## MERGE

merge存储引擎是一组MyISAM表的组合，这些MyISAM表结构必须完全相同，MERGE表中并没有数据，对MERGE类型的表可以进行查询、更新、删除的操作，这些操作实际上是对内部的MyISAM表进行操作。对于对MERGE表进行的插入操作，是根据INSERT\_METHOD子句定义的插入的表，可以有3个不同的值，first和last值使得插入操作被相应的作用在第一个或最后一个表上，不定义这个子句或者为NO，表示不能对这个MERGE表进行插入操作。可以对MERGE表进行drop操作，这个操作只是删除MERGE表的定义，对内部的表没有任何影响。MERGE在磁盘上保留2个以MERGE表名开头文件：.frm文件存储表的定义；.MRG文件包含组合表的信息，包括MERGE表由哪些表组成，插入数据时的依据。可以通过修改.MRG文件来修改MERGE表，但是修改后要通过flush table刷新。

```sql
create table man_all(id int,
 name varchar(20)
 )engine =merge;
 union =(man1,man2) insert_method=last;
```

Merge表中并没有数据，对merge类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行操作。 Merge存储引擎的使用场景

对于服务器日志这种信息，一般常用的存储策略是将数据分成很多表，每个名称与特定的时间段相关。例如，可以用12个相同的表来存储服务器日志数据，每个表对应各个月份的名字来命名，当有必要基于所有12个日志表的数据生成报表，这意味着需要编写并更新多表查询，以反映这些表中的信息。与其编写这些可能出现错误的查询，不如将这些表合并起来使用一条查询，之后再删除Merge表，而不影响原来的数据，删除merge表知识删除merge表的定义，对内部的表没有任何影响

## ISAM

该引擎在读取数据方面速度很快，而且不占用大量的内存和存储资源；但是 ISM 不支持事务处理，不支持外来键，不能够容错，也不支持索引。该引擎在 MySQL 5.1 + （包括 5.1）中不再支持。

## Berkley\(BDB\)

 该存储引擎支持COMMIT和ROLLBACK等其他事务特性。该引擎在包括MySQL 5.1及其以上版本的数据库中不再支持。

