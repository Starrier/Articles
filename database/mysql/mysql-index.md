## Index

一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，
在生产环境中，我们遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，因此对查询语句的优化显然是重中之重。
说起加速查询，就不得不提到索引了。

### 索引的作用

在 MySQL 中，也叫做“键”，是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响也愈发重要。索引优化应该是对查询性能优化最有效的手段了。索引能够轻易将查询性能提高好几个数量级。索引相当于字典的音序表，如果要查某个字，如果不使用音序表，则需要从几百页中逐页去查。

### 索引的类型

#### 1.基本索引

没有任何限制。

创建索引：

``` sql
create index indexName on table_name(username(length))
```

**注意**: 如果是 char，varchar 类型，length 可以小于字段实际长度；如果是 blob 和 text 类型，必须制定 length。

修改表结构：

```sql
alter table_name add index[indexName] on (username(length))
--或者在创建时直接指定--
create table table_name(id int not null,username varchar(16) not null,index[indexName](length))
```

#### 2. 唯一索引

唯一索引与普通索引不同，唯一索引的值必须是唯一的，但允许有空值。如果是组合索引，则列值的组合必须唯一。

```sql
create unique index index_name ON table_name(usernaem(length))
---修改表结构---
ALTER table_name ADD UNIQUE[indexName] ON (usernaem(length))
---创建表时就直接指定---
CREATE TABLE table_name（ID INT NOT NULL，useranem VARCHAR(16) NOT NULL,UNIQUE[indexName](username(length)));
```

#### 3. 主键索引

这是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引。

```sql
 CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, PRIMARY KEY(ID) );
```

**注意**：可以用 ALTER 命令，但一个表只能有一个主键。

#### 4. 组合索引

为了形象地对比单列索引和组合索引，为表添加多个字段：

```sql
CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, city VARCHAR(50) NOT NULL, age INT NOT NULL );
```

为了进一步榨取 MySQL 的效率，就要考虑建立组合索引。就是将 name, city, age 建到一个索引里：

```sql
ALTER TABLE mytable ADD INDEX name_city_age (name(10),city,age);
```

建表时，usernname 长度为 16，这里用 10。这是因为一般情况下名字的长度不会超过10，这样会加速索引查询速度，还会减少索引文件的大小，提高 INSERT 的更新速度。
  
如果分别在 usernname，city，age 上建立单列索引，让该表有 3 个单列索引，查询时和上述的组合索引效率也会大不一样，远远低于我们的组合索引。虽然此时有了三个索引，但 MySQL 只能用到其中的那个它认为似乎是最有效率的单列索引。建立这样的组合索引，其实是相当于分别建立了下面三组组合索引：

```sql
usernname,city,age usernname,city usernname
```

为什么没有 city，age 这样的组合索引呢?这是因为 MySQL 组合索引“最左前缀”的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这三列的查询都会用到该组合索引，下面的几个 SQ L就会用到这个组合索引：

```sql
SELECT * FROM mytable WHREE username="admin" AND city="郑州" 　　SELECT * FROM mytable WHREE username="admin"
```

而下面几个则不会用到：

```sql
SELECT * FROM mytable WHREE age=20 AND city="郑州" 　　SELECT * FROM mytable WHREE city="郑州"
```

### 建立索引的时机

到这里我们已经学会了建立索引，那么我们需要在什么情况下建立索引呢?一般来说，在 WHERE 和 JOIN 中出现的列需要建立索引，但也不完全如此，因为 MySQL 只对 <，<=，=，>，>=，BETWEEN，IN，以及某些时候的 LIKE 才会使用索引。例如：

```sql
SELECT t.Name FROM mytable t LEFT JOIN mytable m ON t.Name=m.username WHERE m.age=20 AND m.city='郑州'
```

此时就需要对 city 和 age 建立索引，由于 mytable 表的 userame 也出现在了 JOIN 子句中，也有对它建立索引的必要。
刚才提到只有某些时候的 LIKE 才需建立索引。因为在以通配符 `%` 和 `_` 开头作查询时，MySQL 不会使用索引。例如下句会使用索引：

```sql
SELECT * FROM mytable WHERE username like'admin%'
```

而下句就不会使用：

```sql
SELECT * FROM mytable WHERE userName like'%admin'
```

因此，在使用 LIKE 时应注意以上的区别。

### 索引的不足之处

上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：

 1. 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行 INSERT、UPDATE 和 DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件。
 2. 建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。

索引只是提高效率的一个因素，如果你的 MySQ L有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。

### 使用索引的注意事项

使用索引时，有以下一些技巧和注意事项：

 1. 索引不会包含有NULL值的列

只要列中包含有 NULL 值都将不会被包含在索引中，复合索引中只要有一列含有 NULL 值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为 NULL。

 2. 使用短索引

对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个 CHAR(255) 的列，如果在前 10 个或 20 个字符内，多数值是唯一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和 I/O 操作。

 3. 索引列排序

MySQL查询只使用一个索引，因此如果 where 子句中已经使用了索引的话，那么 order by 中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作;尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。

 4. like语句操作

一般情况下不鼓励使用 like 操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而 like “aaa%”可以使用索引。

 5. 不要在列上进行运算

```sql
select * from users where YEAR(adddate)<2007;
```

将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成

```sql
select * from users where adddate<‘2007-01-01’;
```

 6. 不使用 NOT IN 和 <> 操作

### 索引的原理

1 索引原理

**目的**：提高查询效率

**本质**  通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，有了这种索引机制，可以总是用同一种查找方式来锁定数据。

2 磁盘IO与预读

磁盘 IO 和预读，磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分：

 1. 寻道时间  指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在 5ms 以下；
 2. 旋转延迟  就是我们经常听说的磁盘转速，比如一个磁盘 7200 转，表示每分钟能转 7200 次，也就是说 1 秒钟能转 120 次，旋转延迟就是 1/120/2 = 4.17ms；
 3. 传输时间 指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。一次磁盘的时间，即一次磁盘IO的时间约等于 5+4.17 = 9ms 左右，听起来还挺不错的，但 一台 500 -MIPS（Million Instructions Per Second）的机器每秒可以执行 5 亿条指令，

磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次 IO 时，不光把当前磁盘地址的数据，还包括相邻的数据也都读取到内存缓冲区内，因为**局部预读性原理**告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次 IO 读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为 4 k 或 8 k，也就是我们读取一页内的数据时候，实际上才发生了一次 IO，对索引的数据结构设计非常有帮助。

3 索引的数据结构

任何一种数据结构都不是凭空产生的，一定会有它的背景和使用场景，要每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。多路搜索树， b+树 应运而生。

![mysql-index-bTree](../_posts/mysql-index/index.png)

        索引 === 平衡树  ---btree  (树的平衡---高度)  ====== 减少IO

                         磁盘块(数据项+指针)
          磁盘块(数据项+指针)              磁盘块(数据项+指针)
真实的数据项     真实的数据项    真实的数据项    真实的数据项    真实的数据项    (叶子节点)

浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。

b+树的查找过程

如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。

b+树性质

索引字段要尽量的小：

通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。

索引的最左匹配特性：

当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。

##  索引失效的情况

1. 索引无法存储 null 值

a.单列索引无法储null值，复合索引无法储全为null的值。

　　b.查询时，采用is null条件时，不能利用到索引，只能全表扫描。

　　 为什么索引列无法存储Null值？

　　a.索引是有序的。NULL值进入索引时，无法确定其应该放在哪里。（将索引列值进行建树，其中必然涉及到诸多的比较操作，null 值是不确定值无法　　

　　比较，无法确定null出现在索引树的叶子节点位置。）　

　　b.如果需要把空值存入索引，方法有二：其一，把NULL值转为一个特定的值，在WHERE中检索时，用该特定值查找。其二，建立一个复合索引。例如　

　　create index ind_a on table(col1,1);  通过在复合索引中指定一个非空常量值，而使构成索引的列的组合中，不可能出现全空值。　

2. 不适合键值较少的列（重复数据较多的列）

　　假如索引列TYPE有5个键值，如果有1万条数据，那么 WHERE TYPE = 1将访问表中的2000个数据块。

　　再加上访问索引块，一共要访问大于200个的数据块。

　　如果全表扫描，假设10条数据一个数据块，那么只需访问1000个数据块，既然全表扫描访问的数据块

　　少一些，肯定就不会利用索引了。

3. 前导模糊查询不能利用索引(like '%XX'或者like '%XX%')

　　假如有这样一列code的值为'AAA','AAB','BAA','BAB' ,如果where code like '%AB'条件，由于前面是

　　模糊的，所以不能利用索引的顺序，必须一个个去找，看是否满足条件。这样会导致全索引扫描或者全表扫

　　描。如果是这样的条件where code like 'A % '，就可以查找CODE中A开头的CODE的位置，当碰到B开头的

　　数据时，就可以停止查找了，因为后面的数据一定不满足要求。这样就可以利用索引了。

4. 索引失效的几种情况

- 如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)。要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引
- 对于多列索引，不是使用的第一部分，则不会使用索引
- like查询以%开头
- 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
- 如果mysql估计使用全表扫描要比使用索引快,则不使用索引
- MySQL主要提供2种方式的索引：B-Tree索引，Hash索引

　　B树索引具有范围查找和前缀查找的能力，对于有N节点的B树，检索一条记录的复杂度为O(LogN)。相当于二分查找。

　哈希索引只能做等于查找，但是无论多大的Hash表，查找复杂度都是O(1)。

　　显然，如果值的差异性大，并且以等值查找（=、 <、>、in）为主，Hash索引是更高效的选择，它有O(1)的查找复杂度。

　　如果值的差异性相对较差，并且以范围查找为主，B树是更好的选择，它支持范围查找。