---
title: mysql-enginer
date: 2019-02-17 23:34:30
tags: mysql
index_img: ../post_img/mysql-enginer.jpeg
---

# MySQL 引擎

![Version 5.7.18](../_posts/mysql-enginer/mysqlenginers.png)

关系数据库表是用于存储和组织信息的数据结构，可以将表理解为由行和列组成的表格，类似于Excel的电子表格的形式。有的表简单，有的表复杂，有的表根本不用来存储任何长期的数据，有的表读取时非常快，但是插入数据时去很差；而我们在实际开发过程中，就可能需要各种各样的表，不同的表，就意味着存储不同类型的数据，数据的处理上也会存在着差异，那么。对于MySQL来说，它提供了很多种类型的存储引擎，我们可以根据对数据处理的需求，选择不同的存储引擎，从而最大限度的利用MySQL强大的功能。这篇博文将总结和分析各个引擎的特点，以及适用场合，并不会纠结于更深层次的东西。我的学习方法是先学会用，懂得怎么用，再去知道到底是如何能用的。下面就对MySQL支持的存储引擎进行简单的介绍。

## 如何选用合适的存储引擎

1. 是否需要支持事务
2. 是否需要使用热备
3. 是否需要外键支持
4. 奔溃恢复：能否接受奔溃

## MylSAM

它不支持事务，也不支持外键，但是访问速度快，对事务完整性没有要求或者以 SELECT、INSERT 为主的应用基本都可以使用这个引擎来创建表。

该引擎基于 ISAM 数据库引擎，除了提供 ISAM 里所没有的索引和字段管理等大量功能，MyISAM 还使用一种表格锁定的机制来优化多个并发的读写操作，但是需要经常运行 OPTIMIZE TABLE 命令，来恢复被更新机制所浪费的空间，否则碎片也会随之增加，最终影响数据访问性能。MyISAM 还有一些有用的扩展，例如用来修复数据库文件的 MyISAMChk 工具和用来恢复浪费空间的 MyISAMPack 工具。MyISAM 强调了快速读取操作，主要用于高负载的 select，这可能也是 MySQL 深受 Web 开发者喜爱的主要原因：在 Web 开发中进行的大量数据操作都是读取操作，所以大多数虚拟主机提供商和 Internet 平台提供商（Internet Presence Provider，IPP）只允许使用 MyISAM 格式。

每个 MyISAM 在磁盘上存储成 3 个文件，其中文件名和表名都相同，但是扩展名分别为：

* .frm\(存储表定义\)
* MYD\(MYData，存储数据\)
* MYI\(MYIndex，存储索引\)

数据文件和索引文件可以放置在不同的目录，平均分配 IO，获取更快的速度。要指定数据文件和索引文件的路径，需要在创建表的时候通过 DATA DIRECTORY 和 INDEX DIRECTORY 语句指定，文件路径需要使用绝对路径。

每个 MyISAM 表都有一个标志，服务器或 myisamchk 程序在检查 MyISAM 数据表时会对这个标志进行设置。MyISAM 表还有一个标志用来表明该数据表在上次使用后是不是被正常的关闭了。如果服务器宕机或崩溃，这个标志可以用来判断数据表是否需要检查和修复。如果想让这种检查自动进行，可以在启动服务器时使用 --myisam-recover 现象。这会让服务器在每次打开一个 MyISAM 据表是自动检查数据表的标志并进行必要的修复处理。MyISAM 类型的表可能会损坏，可以使用 CHECK TABLE 语句来检查 MyISAM 表的健康，并用 REPAIR TABLE语 句修复一个损坏到 MyISAM 表。  

MyISAM的表还支持3种不同的存储格式：

* 静态（固定长度）表
* 动态表
* 压缩表

静态型：指定义的表列的大小是固定（即不含有：xblob、xtext、varchar 等长度可变的数据类型），这样 MySQL 就会自动使用静态 MyISAM 格式。使用静态格式的表的性能比较高，因为在维护和访问以预定格式存储数据时需要的开销很低；但这种高性能是以空间为代价换来的，因为在定义的时候是固定的，所以不管列中的值有多大，都会以最大值为准，占据了整个空间。 动态型：如果列（即使只有一列）定义为动态的（xblob, xtext, varchar 等数据类型），这时 MyISAM 就自动使用动态型，虽然动态型的表占用了比静态型表较少的空间，但带来了性能的降低，因为如果某个字段的内容发生改变则其位置很可能需要移动，这样就会导致碎片的产生，随着数据变化的增多，碎片也随之增加，数据访问性能会随之降低。

对于因碎片增加而降低数据访问性这个问题，有两种解决办法：

   1. 尽可能使用静态数据类型； 
   2. 经常使用 optimize table table\_name 语句整理表的碎片，恢复由于表数据的更新和删除导致的空间丢失。如果存储引擎不支持 optimize table table\_name 则可以转储并 重新加载数据，这样也可以减少碎片；

压缩型：如果在数据库中创建在整个生命周期内只读的表，则应该使用 MyISAM 的压缩型来减少空间的占用。

其中静态表是默认的存储格式。静态表中的字段都是非变长字段，这样每个记录都是固定长度的，这种存储方式的优点是存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多。静态表在数据存储时会根据列定义的宽度定义补足空格，但是在访问的时候并不会得到这些空格，这些空格在返回给应用之前已经去掉。同时需要注意：在某些情况下可能需要返回字段后的空格，而使用这种格式时后面到空格会被自动处理掉。

动态表包含变长字段，记录不是固定长度的，这样存储的优点是占用空间较少，但是频繁到更新删除记录会产生碎片，需要定期执行OPTIMIZE TABLE语句或myisamchk -r命令来改善性能，并且出现故障的时候恢复相对比较困难。  

压缩表由 myisamchk 工具创建，占据非常小的空间，因为每条记录都是被单独压缩的，所以只有非常小的访问开支。

MyISAM 是独立于操作系统的，这说明可以轻松地将其从 windows 服务器移植到 Linux 服务器；每当我们建立一个 MyISAM 引擎的表时，就会在本地磁盘上建立三个文件，文件名就是表名，例如建立一个 MyISAM引擎 的 tb\_Demo 表，就会生成以下三个文件：

|文件名 |意义 |
|---|---|
|tb\_demo.frm| 存储表定义 |
|tb\_demo.MYD | 存储数据 |
|tb\_demo.MYI |存储索引 |

不适用场景：MyISAM 表无法处理事务，这就意味着有事务处理需求的表，不能使用 MyISAM 存储引擎。 适用场景：

* 选择密集型的表。MyISAM 存储引擎在筛选大量数据时非常迅速，这是他最突出的优点
* 插入密集型的表。MyISAM 的并发插入特性允许同时选择和插入数据。例如：MyISAM 存储引擎很适合管理邮件或者 web 服务器日志数据。

## InnoDB

**相比 MyISAM，InnoDB 写的处理效率差一点，并会占用更多的磁盘空间来保留数据和索引**。

InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比 MyISAM 的存储引擎，InnoDB 写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。

**1.自动增长列**

InnoDB 表的自动增长列可以手工插入，但是插入的如果是空或 0，则实际插入到则是自动增长后到值。可以通过 "ALTER TABLE...AUTO\_INCREMENT=n;" 语句强制设置自动增长值的起始值，默认为 1，但是该强制到默认值是保存在内存中，数据库重启后该值将会丢失。可以使用LAST\_INSERT\_ID\()查询当前线程最后插入记录使用的值。如果一次插入多条记录，那么返回的是第一条记录使用的自动增长值。  

对于 InnoDB 表，自动增长列必须是索引。如果是组合索引，也必须是组合索引的第一列，但是对于 MyISAM 表，自动增长列可以是组合索引的其他列，这样插入记录后，自动增长列是按照组合索引到前面几列排序后递增的。

**2.外键约束**

**MySQL 支持外键的存储引擎只有 InnoDB**，在创建外键的时候，父表必须有对应的索引，子表在创建外键的时候也会自动创建对应的索引。  

在创建索引的时候，可以指定在删除、更新父表时，对子表进行的相应操作，包括 restrict、cascade、set null 和 no action。其中 restrict和 no action 相同，是指限制在子表有关联的情况下，父表不能更新；casecade 表示父表在更新或删除时，更新或者删除子表对应的记录；set null 则表示父表在更新或者删除的时候，子表对应的字段被 set null。

当某个表被其它表创建了外键参照，那么该表对应的索引或主键被禁止删除。  

可以使用 set foreign\_key\_checks=0; 临时关闭外键约束，set foreign\_key\_checks=1; 打开约束。

## **MEMORY（HEAP）**

memory 使用存在内存中的内容来创建表。每个 MEMORY 表实际对应一个磁盘文件，格式是 .frm。MEMORY 类型的表访问非常快，因为它到数据是放在内存中的，并且默认使用 HASH 索引，但是一旦服务器关闭，表中的数据就会丢失，但表还会继续存在。

默认情况下，memory 数据表使用散列索引，利用这种索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了。因此，散列索引值适合使用在 "=" 和 "&lt;=&gt;" 的操作符中，不适合使用在 "&lt;" 或 "&gt;" 操作符中，也同样不适合用在 order by 字句里。如果确实要使用 "&lt;" 或 "&gt;" 或 betwen 操作符，可以使用 btree 索引来加快速度。  

存储在 MEMORY 数据表里的数据行使用的是长度不变的格式，因此加快处理速度，这意味着不能使用 BLOB 和 TEXT 这样的长度可变的数据类型。VARCHAR 是一种长度可变的类型，但因为它在 MySQL 内部当作长度固定不变的 CHAR类 型，所以可以使用。

```sql
create table tab_memory engine=memory ;
select id,name,age,addr
from  man order by id;
```

使用 USING HASH/BTREE 来指定特定到索引。

```sql
create index mem_hash using hash on tab_memory(city_id);
```

在启动 MySQL 服务的时候使用 --init-file 选项，把 insert into...select 或 load data infile 这样的语句放入到这个文件中，就可以在服务启动时从持久稳固的数据源中装载表。  

服务器需要足够的内存来维持所在的在同一时间使用的 MEMORY 表，当不再使用 MEMORY 表时，要释放 MEMORY 表所占用的内存，应该执行 DELETE FROM 或 truncate table 或者删除整个表。  

每个 MEMORY 表中放置到数据量的大小，受到 max\_heap\_table\_size 系统变量的约束，这个系统变量的初始值是 16 M，同时在创建 MEMORY 表时可以使用 MAX\_ROWS子 句来指定表中的最大行数。

## ARCHIVE

Archive+ 是归档的意思，在归档之后很多高级功能就不再支持了，仅仅支持最基本的插入和查询两种功能。MySQL5.5 版以前，Archive 是不支持索引，但是在 MySQL5.5以后的版本中就开始支持索引了

Archive 拥有很好的压缩机制，它使用 zlib 压缩库，在记录被请求时会实时压缩，所以它经常被用来当做仓库使用

## MERGE

merge 存储引擎是一组 MyISAM 表的组合，这些 MyISAM 表结构必须完全相同，MERGE 表中并没有数据，对 MERGE 类型的表可以进行查询、更新、删除的操作，这些操作实际上是对内部的 MyISAM表 进行操作。对于对 MERGE 表进行的插入操作，是根据 INSERT\_METHOD 子句定义的插入的表，可以有 3 个不同的值，first 和 last 值使得插入操作被相应的作用在第一个或最后一个表上，不定义这个子句或者为 NO，表示不能对这个 MERGE 表进行插入操作。可以对 MERGE 表进行 drop 操作，这个操作只是删除 MERGE 表的定义，对内部的表没有任何影响。MERGE 在磁盘上保留 2 个以 MERGE 表名开头文件：.frm 文件存储表的定义；.MRG 文件包含组合表的信息，包括M ERGE 表由哪些表组成，插入数据时的依据。可以通过修改 .MRG 文件来修改 MERGE 表，但是修改后要通过 flush table 刷新。

```sql
create table man_all(id int,
 name varchar(20)
 )engine =merge;
 union =(man1,man2) insert_method=last;
```

Merge 表中并没有数据，对 merge 类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的 MyISAM 表进行操作。Merge 存储引擎的使用场景

对于服务器日志这种信息，一般常用的存储策略是将数据分成很多表，每个名称与特定的时间段相关。例如，可以用 12 个相同的表来存储服务器日志数据，每个表对应各个月份的名字来命名，当有必要基于所有 12个 日志表的数据生成报表，这意味着需要编写并更新多表查询，以反映这些表中的信息。与其编写这些可能出现错误的查询，不如将这些表合并起来使用一条查询，之后再删除 Merge 表，而不影响原来的数据，删除 merg e表支持删除 merge 表的定义，对内部的表没有任何影响

## ISAM

该引擎在读取数据方面速度很快，而且不占用大量的内存和存储资源；但是 ISM 不支持事务处理，不支持外来键，不能够容错，也不支持索引。该引擎在 MySQL 5.1 + （包括 5.1）中不再支持。

## Berkley\(BDB\)

 该存储引擎支持 COMMIT 和R OLLBACK 等其他事务特性。该引擎在包括 MySQL 5.1 及其以上版本的数据库中不再支持。