---
title: cache-promble
date: 2019-02-15 23:13:20
tags: Cache
index_img: ../post_img/cache-promblem.jpeg
---

# 缓存问题

## 缓存雪崩

### 可能是因为数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。

1. 加锁计数（即限制并发的数量，可以用 semphore）或者起一定数量的队列来避免缓存失效时大量请求并发到数据库。但这种方式会降低吞吐量。
2. 分析用户行为，然后失效时间均匀分布。或者在失效时间的基础上再加1~5分钟的随机数。
3. 如果是某台缓存服务器宕机，则考虑做主备。

## 缓存穿透

### 指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库中查询

1. 如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库。设置一个过期时间或者当有值的时候将缓存中的值替换掉即可。
2. 可以给key设置一些格式规则，然后查询之前先过滤掉不符合规则的Key。

## 缓存并发

### 如果网站并发访问高，一个缓存如果失效，可能出现多个进程同时查询DB，同时设置缓存的情况，如果并发确实很大，这也可能造成DB压力过大，还有缓存频繁更新的问题

1. 对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询。

## 缓存预热

### 目的就是在系统上线前，将数据加载到缓存中。解决思路

1. 数据量不大的话，在系统启动的时候直接加载。
2. 自己写个简单的缓存预热程序。

## 缓存算法

1. FIFO算法：First in First out，先进先出。原则：一个数据最先进入缓存中，则应该最早淘汰掉。也就是说，当缓存满的时候，应当把最先进入缓存的数据给淘汰掉。
2. LFU算法：Least Frequently Used，最不经常使用算法。
3. LRU算法：Least Recently Used，近期最少使用算法。
4. LRU和LFU的区别。LFU算法是根据在一段时间里数据项被使用的次数选择出最少使用的数据项，即根据使用次数的差异来决定。而LRU是根据使用时间的差异来决定的