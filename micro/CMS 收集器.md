# CMS 收集器

CMS 收集器是一种以获取最短回收停顿时间为目标的收集器。基于“标记-清除”算法实现：

1. 初始标记
2. 并发标记
3. 重新标记
4. 并发清除

初始标记，重新标记这两个步骤仍然需要“Stop the world”，初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，并发标记阶段就是进行 GC Roots Tracing，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生表动的那一部分对象的标记记录，这个阶段的停顿时间一般比初始标记稍长，但远比并发标记短。

CMS 特点：  并发收集，低停顿。

缺点：

1. CMS 收集器对 CPU 资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢。
2. CMS 收集器无法处理浮动垃圾，可能会出现“Concurrent Mode Failure” 失败而导致 Full GC 产生。（浮动垃圾：由于 CMS 鬓发清理阶段用户线程还在运行着，伴随着程序运行自然就会有新的垃圾不断产生，这部分垃圾出现标记过程之后，CMS 无法在当次手机中处理掉它们，只好留待下一次 GC 时，在处理。这些垃圾就是“浮动垃圾”）
3. CMS 是一款“标记-清除”算法实现的收集器，容器出现大量空间碎片。当空间碎片过多，将会给大对象分配带来很大的麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次 FULL GC。


